\hypertarget{class_util}{}\section{Util Class Reference}
\label{class_util}\index{Util@{Util}}


Utilities. Use predefinied methods.  




{\ttfamily \#include $<$Util.\+h$>$}

\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \mbox{\hyperlink{class_util_ad2e7395962790b29850386ec1b67b0b4}{Calculate\+Normals}} (unsigned int $\ast$indices, unsigned int indice\+Count, float $\ast$vertices, unsigned int vertice\+Count, unsigned int v\+Length, unsigned int normal\+Offset)
\item 
static void \mbox{\hyperlink{class_util_ae720e205587c192a38b9f304cdbde242}{Calculate\+Bit\+Angents}} (unsigned int $\ast$vertices, const unsigned int U\+Voffset, const unsigned int vertice\+Offset, const unsigned int vertice\+Count, const unsigned int tangent\+Offset)
\item 
{\footnotesize template$<$typename T $>$ }\\static void \mbox{\hyperlink{class_util_affee8f024e5e4bd88fb0bd79e37c2186}{Swap\+Vector\+Array}} (std\+::vector$<$ T $\ast$ $>$ $\ast$vector)
\item 
static void \mbox{\hyperlink{class_util_a17188b444f62e6ed4e8644b3fcefd1c5}{Check\+For\+Errors}} (N\+E\+\_\+\+E\+R\+R\+OR error, char $\ast$file, int line)
\item 
{\footnotesize template$<$typename T $>$ }\\static void \mbox{\hyperlink{class_util_a3f368c839c02137364295ed412f5b715}{Delete\+Pointer}} (T $\ast$t)
\item 
{\footnotesize template$<$typename T $>$ }\\static void \mbox{\hyperlink{class_util_a96f8de6fe6bf7935cc82954954f10086}{Debug\+Log}} (T t)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Utilities. Use predefinied methods. 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_util_ae720e205587c192a38b9f304cdbde242}\label{class_util_ae720e205587c192a38b9f304cdbde242}} 
\index{Util@{Util}!CalculateBitAngents@{CalculateBitAngents}}
\index{CalculateBitAngents@{CalculateBitAngents}!Util@{Util}}
\subsubsection{\texorpdfstring{CalculateBitAngents()}{CalculateBitAngents()}}
{\footnotesize\ttfamily void Util\+::\+Calculate\+Bit\+Angents (\begin{DoxyParamCaption}\item[{unsigned int $\ast$}]{vertices,  }\item[{const unsigned int}]{U\+Voffset,  }\item[{const unsigned int}]{vertice\+Offset,  }\item[{const unsigned int}]{vertice\+Count,  }\item[{const unsigned int}]{tangent\+Offset }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculate bitangents and return a pointer to the array 
\begin{DoxyParams}{Parameters}
{\em vertices} & Insert vertices as unsigned int array \\
\hline
{\em U\+Voffset} & Insert offset from start to uv coordinates \\
\hline
{\em vertices\+Offset} & Insert offset to new vertices \\
\hline
{\em vertice\+Count} & Insert vertices array count \\
\hline
{\em tangent\+Count} & Insert offset to tangent and bitangent coordinates \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_util_ad2e7395962790b29850386ec1b67b0b4}\label{class_util_ad2e7395962790b29850386ec1b67b0b4}} 
\index{Util@{Util}!CalculateNormals@{CalculateNormals}}
\index{CalculateNormals@{CalculateNormals}!Util@{Util}}
\subsubsection{\texorpdfstring{CalculateNormals()}{CalculateNormals()}}
{\footnotesize\ttfamily void Util\+::\+Calculate\+Normals (\begin{DoxyParamCaption}\item[{unsigned int $\ast$}]{indices,  }\item[{unsigned int}]{indice\+Count,  }\item[{float $\ast$}]{vertices,  }\item[{unsigned int}]{vertice\+Count,  }\item[{unsigned int}]{v\+Length,  }\item[{unsigned int}]{normal\+Offset }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculate normals directly in arrays 
\begin{DoxyParams}{Parameters}
{\em indices} & Insert array to indices as unsigned int indices \\
\hline
{\em indice\+Count} & Insert array size of indices \\
\hline
{\em vertices} & Insert array to vertices as unsigned int indices \\
\hline
{\em indice\+Count} & Insert array size of vertices \\
\hline
{\em v\+Length} & Insert vertice count per vertex \\
\hline
{\em normal\+Offset} & Insert normal count offset from start \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_util_a17188b444f62e6ed4e8644b3fcefd1c5}\label{class_util_a17188b444f62e6ed4e8644b3fcefd1c5}} 
\index{Util@{Util}!CheckForErrors@{CheckForErrors}}
\index{CheckForErrors@{CheckForErrors}!Util@{Util}}
\subsubsection{\texorpdfstring{CheckForErrors()}{CheckForErrors()}}
{\footnotesize\ttfamily void Util\+::\+Check\+For\+Errors (\begin{DoxyParamCaption}\item[{N\+E\+\_\+\+E\+R\+R\+OR}]{error,  }\item[{char $\ast$}]{file,  }\item[{int}]{line }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Check for errors, called via N\+E\+\_\+\+E\+R\+R\+O\+R\+\_\+\+C\+H\+E\+CK 
\begin{DoxyParams}{Parameters}
{\em error} & Insert current N\+E\+\_\+\+E\+R\+R\+OR \\
\hline
{\em file} & Insert current file with {\bfseries{F\+I\+LE}} \\
\hline
{\em line} & Insert current line with {\bfseries{L\+I\+NE}} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_util_a96f8de6fe6bf7935cc82954954f10086}\label{class_util_a96f8de6fe6bf7935cc82954954f10086}} 
\index{Util@{Util}!DebugLog@{DebugLog}}
\index{DebugLog@{DebugLog}!Util@{Util}}
\subsubsection{\texorpdfstring{DebugLog()}{DebugLog()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
static void Util\+::\+Debug\+Log (\begin{DoxyParamCaption}\item[{T}]{t }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Debug log, use N\+E\+\_\+\+E\+R\+R\+O\+R\+\_\+\+C\+H\+E\+C\+K(\+\_\+result) 
\begin{DoxyParams}{Parameters}
{\em t} & Insert output variable as type T\+E\+M\+P\+L\+A\+TE \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_util_a3f368c839c02137364295ed412f5b715}\label{class_util_a3f368c839c02137364295ed412f5b715}} 
\index{Util@{Util}!DeletePointer@{DeletePointer}}
\index{DeletePointer@{DeletePointer}!Util@{Util}}
\subsubsection{\texorpdfstring{DeletePointer()}{DeletePointer()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
static void Util\+::\+Delete\+Pointer (\begin{DoxyParamCaption}\item[{T $\ast$}]{t }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Delete a pointer if not nullptr 
\begin{DoxyParams}{Parameters}
{\em t} & Insert pointer of type T\+E\+M\+P\+L\+A\+TE \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_util_affee8f024e5e4bd88fb0bd79e37c2186}\label{class_util_affee8f024e5e4bd88fb0bd79e37c2186}} 
\index{Util@{Util}!SwapVectorArray@{SwapVectorArray}}
\index{SwapVectorArray@{SwapVectorArray}!Util@{Util}}
\subsubsection{\texorpdfstring{SwapVectorArray()}{SwapVectorArray()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Util\+::\+Swap\+Vector\+Array (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $\ast$ $>$ $\ast$}]{vector }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Swap vector, use N\+E\+\_\+\+S\+W\+A\+P\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+A\+R\+R\+A\+Y(\+\_\+vector\+\_\+array) 
\begin{DoxyParams}{Parameters}
{\em vertor} & Insert std\+::vector of type T\+E\+M\+P\+L\+A\+TE as std\+::vector$<$\+T$\ast$$>$$\ast$ \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
Git\+Hub/\+Nebula\+\_\+\+Engine/\+Nebula\+\_\+\+Engine/Util.\+h\item 
Git\+Hub/\+Nebula\+\_\+\+Engine/\+Nebula\+\_\+\+Engine/Util.\+cpp\end{DoxyCompactItemize}
